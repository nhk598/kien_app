{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { print } from 'graphql';\nimport { invariant } from 'ts-invariant';\nimport { ApolloLink } from \"../core/index.js\";\nimport { Observable, compact } from \"../../utilities/index.js\";\nexport var VERSION = 1;\nvar PersistedQueryLink;\n\n(function (PersistedQueryLink) {\n  ;\n  ;\n  ;\n})(PersistedQueryLink || (PersistedQueryLink = {}));\n\nvar defaultOptions = {\n  disable: function (_a) {\n    var graphQLErrors = _a.graphQLErrors,\n        operation = _a.operation;\n\n    if (graphQLErrors && graphQLErrors.some(function (_a) {\n      var message = _a.message;\n      return message === 'PersistedQueryNotSupported';\n    })) {\n      return true;\n    }\n\n    var response = operation.getContext().response;\n\n    if (response && response.status && (response.status === 400 || response.status === 500)) {\n      return true;\n    }\n\n    return false;\n  },\n  useGETForHashedQueries: false\n};\n\nfunction operationDefinesMutation(operation) {\n  return operation.query.definitions.some(function (d) {\n    return d.kind === 'OperationDefinition' && d.operation === 'mutation';\n  });\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar hashesByQuery = new WeakMap();\nvar nextHashesChildKey = 0;\nexport var createPersistedQueryLink = function (options) {\n  __DEV__ ? invariant(options && (typeof options.sha256 === 'function' || typeof options.generateHash === 'function'), 'Missing/invalid \"sha256\" or \"generateHash\" function. Please ' + 'configure one using the \"createPersistedQueryLink(options)\" options ' + 'parameter.') : invariant(options && (typeof options.sha256 === 'function' || typeof options.generateHash === 'function'), 27);\n\n  var _a = compact(defaultOptions, options),\n      sha256 = _a.sha256,\n      _b = _a.generateHash,\n      generateHash = _b === void 0 ? function (query) {\n    return Promise.resolve(sha256(print(query)));\n  } : _b,\n      disable = _a.disable,\n      useGETForHashedQueries = _a.useGETForHashedQueries;\n\n  var supportsPersistedQueries = true;\n  var hashesChildKey = 'forLink' + nextHashesChildKey++;\n\n  var getHashPromise = function (query) {\n    return new Promise(function (resolve) {\n      return resolve(generateHash(query));\n    });\n  };\n\n  function getQueryHash(query) {\n    if (!query || typeof query !== 'object') {\n      return getHashPromise(query);\n    }\n\n    var hashes = hashesByQuery.get(query);\n    if (!hashes) hashesByQuery.set(query, hashes = Object.create(null));\n    return hasOwnProperty.call(hashes, hashesChildKey) ? hashes[hashesChildKey] : hashes[hashesChildKey] = getHashPromise(query);\n  }\n\n  return new ApolloLink(function (operation, forward) {\n    __DEV__ ? invariant(forward, 'PersistedQueryLink cannot be the last link in the chain.') : invariant(forward, 28);\n    var query = operation.query;\n    return new Observable(function (observer) {\n      var subscription;\n      var retried = false;\n      var originalFetchOptions;\n      var setFetchOptions = false;\n\n      var retry = function (_a, cb) {\n        var response = _a.response,\n            networkError = _a.networkError;\n\n        if (!retried && (response && response.errors || networkError)) {\n          retried = true;\n          var disablePayload = {\n            response: response,\n            networkError: networkError,\n            operation: operation,\n            graphQLErrors: response ? response.errors : undefined\n          };\n          supportsPersistedQueries = !disable(disablePayload);\n\n          if (response && response.errors && response.errors.some(function (_a) {\n            var message = _a.message;\n            return message === 'PersistedQueryNotFound';\n          }) || !supportsPersistedQueries) {\n            if (subscription) subscription.unsubscribe();\n            operation.setContext({\n              http: {\n                includeQuery: true,\n                includeExtensions: supportsPersistedQueries\n              },\n              fetchOptions: {\n                method: 'POST'\n              }\n            });\n\n            if (setFetchOptions) {\n              operation.setContext({\n                fetchOptions: originalFetchOptions\n              });\n            }\n\n            subscription = forward(operation).subscribe(handler);\n            return;\n          }\n        }\n\n        cb();\n      };\n\n      var handler = {\n        next: function (response) {\n          retry({\n            response: response\n          }, function () {\n            return observer.next(response);\n          });\n        },\n        error: function (networkError) {\n          retry({\n            networkError: networkError\n          }, function () {\n            return observer.error(networkError);\n          });\n        },\n        complete: observer.complete.bind(observer)\n      };\n      operation.setContext({\n        http: {\n          includeQuery: !supportsPersistedQueries,\n          includeExtensions: supportsPersistedQueries\n        }\n      });\n\n      if (useGETForHashedQueries && supportsPersistedQueries && !operationDefinesMutation(operation)) {\n        operation.setContext(function (_a) {\n          var _b = _a.fetchOptions,\n              fetchOptions = _b === void 0 ? {} : _b;\n          originalFetchOptions = fetchOptions;\n          return {\n            fetchOptions: __assign(__assign({}, fetchOptions), {\n              method: 'GET'\n            })\n          };\n        });\n        setFetchOptions = true;\n      }\n\n      if (supportsPersistedQueries) {\n        getQueryHash(query).then(function (sha256Hash) {\n          operation.extensions.persistedQuery = {\n            version: VERSION,\n            sha256Hash: sha256Hash\n          };\n          subscription = forward(operation).subscribe(handler);\n        }).catch(observer.error.bind(observer));\n        ;\n      } else {\n        subscription = forward(operation).subscribe(handler);\n      }\n\n      return function () {\n        if (subscription) subscription.unsubscribe();\n      };\n    });\n  });\n};","map":{"version":3,"sources":["../../../src/link/persisted-queries/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { print } from 'graphql';\nimport {\n  DocumentNode,\n  ExecutionResult,\n  GraphQLError,\n} from 'graphql';\nimport { invariant } from 'ts-invariant';\n\nimport { ApolloLink, Operation } from '../core';\nimport { Observable, Observer, compact } from '../../utilities';\n\nexport const VERSION = 1;\n\nexport interface ErrorResponse {\n  graphQLErrors?: readonly GraphQLError[];\n  networkError?: Error;\n  response?: ExecutionResult;\n  operation: Operation;\n}\n\ntype SHA256Function = (...args: any[]) => string | PromiseLike<string>;\ntype GenerateHashFunction = (document: DocumentNode) => string | PromiseLike<string>;\n\nnamespace PersistedQueryLink {\n  interface BaseOptions {\n    disable?: (error: ErrorResponse) => boolean;\n    useGETForHashedQueries?: boolean;\n  };\n\n  interface SHA256Options extends BaseOptions {\n    sha256: SHA256Function;\n    generateHash?: never;\n  };\n\n  interface GenerateHashOptions extends BaseOptions {\n    sha256?: never;\n    generateHash: GenerateHashFunction;\n  };\n\n  export type Options = SHA256Options | GenerateHashOptions;\n}\n\nconst defaultOptions = {\n  disable: ({ graphQLErrors, operation }: ErrorResponse) => {\n    // if the server doesn't support persisted queries, don't try anymore\n    if (\n      graphQLErrors &&\n      graphQLErrors.some(\n        ({ message }) => message === 'PersistedQueryNotSupported',\n      )\n    ) {\n      return true;\n    }\n\n    const { response } = operation.getContext();\n    // if the server responds with bad request\n    // apollo-server responds with 400 for GET and 500 for POST when no query is found\n    if (\n      response &&\n      response.status &&\n      (response.status === 400 || response.status === 500)\n    ) {\n      return true;\n    }\n\n    return false;\n  },\n  useGETForHashedQueries: false,\n};\n\nfunction operationDefinesMutation(operation: Operation) {\n  return operation.query.definitions.some(\n    d => d.kind === 'OperationDefinition' && d.operation === 'mutation');\n}\n\nconst { hasOwnProperty } = Object.prototype;\n\nconst hashesByQuery = new WeakMap<\n  DocumentNode,\n  Record<string, Promise<string>>\n>();\n\nlet nextHashesChildKey = 0;\n\nexport const createPersistedQueryLink = (\n  options: PersistedQueryLink.Options,\n) => {\n  // Ensure a SHA-256 hash function is provided, if a custom hash\n  // generation function is not provided. We don't supply a SHA-256 hash\n  // function by default, to avoid forcing one as a dependency. Developers\n  // should pick the most appropriate SHA-256 function (sync or async) for\n  // their needs/environment, or provide a fully custom hash generation\n  // function (via the `generateHash` option) if they want to handle\n  // hashing with something other than SHA-256.\n  invariant(\n    options && (\n      typeof options.sha256 === 'function' ||\n      typeof options.generateHash === 'function'\n    ),\n    'Missing/invalid \"sha256\" or \"generateHash\" function. Please ' +\n      'configure one using the \"createPersistedQueryLink(options)\" options ' +\n      'parameter.'\n  );\n\n  const {\n    sha256,\n    // If both a `sha256` and `generateHash` option are provided, the\n    // `sha256` option will be ignored. Developers can configure and\n    // use any hashing approach they want in a custom `generateHash`\n    // function; they aren't limited to SHA-256.\n    generateHash = (query: DocumentNode) =>\n      Promise.resolve<string>(sha256!(print(query))),\n    disable,\n    useGETForHashedQueries\n  } = compact(defaultOptions, options);\n\n  let supportsPersistedQueries = true;\n\n  const hashesChildKey = 'forLink' + nextHashesChildKey++;\n\n  const getHashPromise = (query: DocumentNode) =>\n    new Promise<string>(resolve => resolve(generateHash(query)));\n\n  function getQueryHash(query: DocumentNode): Promise<string> {\n    if (!query || typeof query !== 'object') {\n      // If the query is not an object, we won't be able to store its hash as\n      // a property of query[hashesKey], so we let generateHash(query) decide\n      // what to do with the bogus query.\n      return getHashPromise(query);\n    }\n    let hashes = hashesByQuery.get(query)!;\n    if (!hashes) hashesByQuery.set(query, hashes = Object.create(null));\n    return hasOwnProperty.call(hashes, hashesChildKey)\n      ? hashes[hashesChildKey]\n      : hashes[hashesChildKey] = getHashPromise(query);\n  }\n\n  return new ApolloLink((operation, forward) => {\n    invariant(\n      forward,\n      'PersistedQueryLink cannot be the last link in the chain.'\n    );\n\n    const { query } = operation;\n\n    return new Observable((observer: Observer<ExecutionResult>) => {\n      let subscription: ZenObservable.Subscription;\n      let retried = false;\n      let originalFetchOptions: any;\n      let setFetchOptions = false;\n      const retry = (\n        {\n          response,\n          networkError,\n        }: { response?: ExecutionResult; networkError?: Error },\n        cb: () => void,\n      ) => {\n        if (!retried && ((response && response.errors) || networkError)) {\n          retried = true;\n\n          const disablePayload = {\n            response,\n            networkError,\n            operation,\n            graphQLErrors: response ? response.errors : undefined,\n          };\n\n          // if the server doesn't support persisted queries, don't try anymore\n          supportsPersistedQueries = !disable(disablePayload);\n\n          // if its not found, we can try it again, otherwise just report the error\n          if (\n            (response &&\n              response.errors &&\n              response.errors.some(\n                ({ message }: { message: string }) =>\n                  message === 'PersistedQueryNotFound',\n              )) ||\n            !supportsPersistedQueries\n          ) {\n            // need to recall the link chain\n            if (subscription) subscription.unsubscribe();\n            // actually send the query this time\n            operation.setContext({\n              http: {\n                includeQuery: true,\n                includeExtensions: supportsPersistedQueries,\n              },\n              fetchOptions: {\n                // Since we're including the full query, which may be\n                // large, we should send it in the body of a POST request.\n                // See issue #7456.\n                method: 'POST',\n              },\n            });\n            if (setFetchOptions) {\n              operation.setContext({ fetchOptions: originalFetchOptions });\n            }\n            subscription = forward(operation).subscribe(handler);\n\n            return;\n          }\n        }\n        cb();\n      };\n      const handler = {\n        next: (response: ExecutionResult) => {\n          retry({ response }, () => observer.next!(response));\n        },\n        error: (networkError: Error) => {\n          retry({ networkError }, () => observer.error!(networkError));\n        },\n        complete: observer.complete!.bind(observer),\n      };\n\n      // don't send the query the first time\n      operation.setContext({\n        http: {\n          includeQuery: !supportsPersistedQueries,\n          includeExtensions: supportsPersistedQueries,\n        },\n      });\n\n      // If requested, set method to GET if there are no mutations. Remember the\n      // original fetchOptions so we can restore them if we fall back to a\n      // non-hashed request.\n      if (\n        useGETForHashedQueries &&\n        supportsPersistedQueries &&\n        !operationDefinesMutation(operation)\n      ) {\n        operation.setContext(\n          ({ fetchOptions = {} }: { fetchOptions: Record<string, any> }) => {\n            originalFetchOptions = fetchOptions;\n            return {\n              fetchOptions: {\n                ...fetchOptions,\n                method: 'GET',\n              },\n            };\n          },\n        );\n        setFetchOptions = true;\n      }\n\n      if (supportsPersistedQueries) {\n        getQueryHash(query).then((sha256Hash) => {\n          operation.extensions.persistedQuery = {\n            version: VERSION,\n            sha256Hash,\n          };\n          subscription = forward(operation).subscribe(handler);\n        }).catch(observer.error!.bind(observer));;\n      } else {\n        subscription = forward(operation).subscribe(handler);\n      }\n\n      return () => {\n        if (subscription) subscription.unsubscribe();\n      };\n    });\n  });\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}